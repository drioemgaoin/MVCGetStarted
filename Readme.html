<h1 id="application-lifecycle">Application lifecycle</h1>
<p>MVC Application lifecycle contains two events:</p>
<ul>
<li>Start event: fired when the application is brought to life by a very first request to the application.</li>
<li>End event: fired when the application has been shut down.</li>
</ul>
<p><img src="./img/application-lifecycle.jpg" alt="Application Lifecycle" /></p>
<p>MVC application provide two handlers to these events in Global.asax file. Start handler is usually used to register all areas of MVC application, installing global filters, adding routes and bundles.</p>
<h1 id="request-lifecycle">Request lifecycle</h1>
<p><img src="./img/request-lifecycle.jpg" alt="Request Lifecycle" /></p>
<h2 id="routing">Routing</h2>
<h3 id="url-routing-module">Url Routing Module</h3>
<p>It analyses the request and looks up Routing table to find the controller the incoming request maps to.</p>
<p><img src="./img/url-routing-module.jpg" alt="Url Routing Module" /></p>
<p>It analyses the request and makes the route selection. It loops through the RouteData from a RouteTable and selects the first route which matches the current URL. If no routes found then the Url Routing Module sends the request to regular ASP.NET or IIS request processing.</p>
<p><img src="./img/route-selection.jpg" alt="Route Selection" /></p>
<p>Routes are added in the start handler in the Global.asax file. You have many way to add them:</p>
<ul>
<li>Use Route object</li>
</ul>
<pre><code class="language-C#">var routeValue = new RouteValueDictionary
{
    { &quot;Controller&quot;, &quot;Home&quot; },
    { &quot;Action&quot;, &quot;Index&quot; }
};
routes.Add(new Route(&quot;home&quot;, routeValue, new MvcRouteHandler()));
</code></pre>
<ul>
<li>Use MapRoute from the RouteCollection object</li>
</ul>
<pre><code class="language-C#">routes.MapRoute(
    name: &quot;Default&quot;,
    url: &quot;{controller}/{action}/{id}&quot;,
    defaults: new { controller = &quot;Home&quot;, action = &quot;Index&quot;, id = UrlParameter.Optional }
</code></pre>
<ul>
<li>Use MapMvcAttributeRoutes</li>
</ul>
<pre><code class="language-C#">routes.MapMvcAttributeRoutes();

public class HomeController : Controller
{
    [Route(&quot;Home&quot;, Name = &quot;Index&quot;)]
    public ActionResult Index()
    {
        return View();
    }
}
</code></pre>
<p>You can define constraints to a route by using:</p>
<ul>
<li><p>Regular expressions</p>
<ul>
<li><p>Using MapRoute</p>
<pre><code class="language-C#">routes.MapRoute(
    name: &quot;RegExpRouteConstraint&quot;,
    url: &quot;TestRouteConstraint/Regexp/{user}&quot;,
    defaults: new { controller = &quot;TestRouteConstraint&quot;, action = &quot;RegularExpressionConstraint&quot;, user = UrlParameter.Optional },
    constraints: new { user = &quot;rdiegoni&quot; } // 'user' identifies the parameter that the constraint applies to
);

// localhost/TestRouteConstraint/Custom/rdiegoni resource found
// localhost/TestRouteConstraint/Custom/xxx resource not found
</code></pre>
</li>
<li><p>Using RouteAttribute</p>
<pre><code class="language-C#">[Route(&quot;TestRouteConstraint/Regexp/{user:regex(rdiegoni)}&quot;, Name = &quot;TestRouteConstraint_RegularExpressionConstraint&quot;)]
public ActionResult RegularExpressionConstraint(string user)
{
    ViewBag.Message = &quot;Regular Expression Constraint sucess&quot;;
    return View(&quot;Result&quot;);
}
</code></pre>
</li>
</ul>
</li>
<li><p>Objects that implement the IRouteConstraint interface</p>
<pre><code class="language-C#">public class CustomRouteConstraint: IRouteConstraint
{
    private readonly List&lt;string&gt; users;

    public CustomRouteConstraint(string users)
    {
        this.users = users.Split('|').Select(x =&gt; x.ToLower()).ToList();
    }

    public bool Match(
        HttpContextBase httpContext, 
        Route route, 
        string parameterName, 
        RouteValueDictionary values,
        RouteDirection routeDirection)
    {
        var value = values[parameterName].ToString();
        return users.Contains(value.ToLower());
    }
}
</code></pre>
<p>Then, register it in Global.asax file</p>
<pre><code class="language-C#">var constraintsResolver = new DefaultInlineConstraintResolver();
constraintsResolver.ConstraintMap.Add(&quot;match&quot;, typeof(CustomRouteConstraint));
</code></pre>
<ul>
<li><p>Using MapRoute</p>
<pre><code class="language-C#">routes.MapRoute(
    name: &quot;CustomRouteConstraint&quot;,
    url: &quot;TestRouteConstraint/Custom/{user}&quot;,
    defaults: new { controller = &quot;TestRouteConstraint&quot;, action = &quot;CustomRouteConstraint&quot;, user = UrlParameter.Optional },
    constraints: new { user = new CustomRouteConstraint(&quot;rdiegoni&quot;) } // 'user' identifies the parameter that the constraint applies to
);
</code></pre>
</li>
<li><p>Using RouteAttribute</p>
<pre><code class="language-C#">[Route(&quot;TestRouteConstraint/Custom/{user:match(rdiegoni)}&quot;, Name = &quot;TestRouteConstraint_CustomRouteConstraint&quot;)]
public ActionResult CustomRouteConstraint(string user)
{
    ViewBag.Message = &quot;Custom Route Constraint sucess&quot;;
    return View(&quot;Result&quot;);
}
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="route-handler">Route Handler</h3>
<p>It is a class returning the http handler that will handle the incoming request.</p>
<p>To create a new route handler, you need to create a class that derives from IRouteHandler and return an instance of the custom handler in the GetHttpHandler method.</p>
<pre><code class="language-C#">public class MyRouteHandler : IRouteHandler
{
    public IHttpHandler GetHttpHandler(RequestContext requestContext)
    {
        return new MyHttpHandler();
    }
}
</code></pre>
<p>Then, you need to associate this handler to the routes you want to apply with.</p>
<pre><code class="language-C#">routes.Add(new Route(&quot;route&quot;, new MyRouteHandler()));
</code></pre>
<p>MVC uses MVCRouteHandler as a default route handler.</p>
<h3 id="http-handler">Http Handler</h3>
<p>It is a class that provides a response to the incoming request.</p>
<p>To create a custom http handler, you need to create a class that derives from IHttpHandler.</p>
<pre><code class="language-C#">public class MyHttpHandler: IHttpHandler
{
    public void ProcessRequest(HttpContext context)
    {
        context.Response.Redirect(&quot;https://github.com/drioemgaoin&quot;, true);
    }
}
</code></pre>
<p>MVC uses MVCHttpHandler as a default http handler. It is the entry point of MVC framework.</p>
<p>There are two sets of events in the MVC request lifecycle that concerns HttpHandlers:</p>
<ul>
<li>MapRequestHandler and PostMapRequestHandler: determines the httpHandler responsible for executing the request. Only the selection happens during this time.</li>
<li>RequestHandlerExecute and PostRequestHandlerExecute: executes the htttp handler determined in the earlier phases of request lifecycle.</li>
</ul>
<p><img src="./img/http-handler.jpg" alt="Route Selection" /></p>
<h2 id="controller-initialization">Controller Initialization</h2>
<p><img src="./img/controller-initialization.jpg" alt="Route Selection" /></p>
<p>Once the http handler determinated, it starts to process the request by inspecting the RequestContext to get the name of the Controller from the URL.</p>
<p>Then, it uses the ControllerBuilder to get the ControllerFactory instance.</p>
<p>Then, it passes the name of the Controller and RequestContext to the CreateController (ControllerFactory method) to create the controller by using Controller Activator and Dependency Resolver. If no dependency resolved was found then Controller Activator manually creates an instance of controller and returns it for execution. Once the controller has been initialized MvcHandler calls controller.Execute() method to begin processing execution.</p>
<p>Finally, it calls the controller’s Execute method and passes the RequestContext to Controller.</p>
<p>MVC uses DefaultControllerFactory as a default controller factory.</p>
<p>To create a custom controller factory, you need to:</p>
<ul>
<li>Create a class that derives from IControllerFactory (or DefaultControllerFactory).</li>
</ul>
<pre><code class="language-C#">public class MyControllerFactory : IControllerFactory
{
    // You can use your favourite IoC tool to inject the dependencies needed by each controller
    // Activator.CreateInstance(controller, dependencies)

    public IController CreateController(RequestContext requestContext, string controllerName)
    {
        var controllername = $&quot;{requestContext.RouteData.Values[&quot;controller&quot;]}Controller&quot;;

        var controllers = GetControllers();
        var controller = controllers.FirstOrDefault(x =&gt; x.Name == controllername);
        if (controller != null)
        {
            return Activator.CreateInstance(controller) as IController;
        }

        return null;
    }

    public SessionStateBehavior GetControllerSessionBehavior(RequestContext requestContext, string controllerName)
    {
        return SessionStateBehavior.Default;
    }

    public void ReleaseController(IController controller)
    {
        var dispose = controller as IDisposable;
        dispose?.Dispose();
    }

    private static IEnumerable&lt;Type&gt; GetControllers()
    {
        var myAssembly = Assembly.GetExecutingAssembly();
        return myAssembly.GetTypes()
            .Where(x =&gt; x.IsClass &amp;&amp; x.Name.EndsWith(&quot;Controller&quot;)).ToList();
    }
}
</code></pre>
<ul>
<li>Set this factory as a new controller factory in Global.asax file.</li>
</ul>
<pre><code class="language-C#">ControllerBuilder.Current.SetControllerFactory(typeof(MyControllerFactory));
</code></pre>
<h2 id="action-execution">Action Execution</h2>
<p><img src="./img/action-execution.jpg" alt="Route Selection" /></p>
<p>Once the controller has been chosen and initialized, execution start by using an Action Invoker that will select appropriate method using route data and method names.</p>
<p>Once the selection is done, Authentication filters fires to ensure that current user is authenticated. If the authentication fails then a challenge is sent back to the use, which could involve redirect user to a login page. If the authentication passes, request moves ahead with authorization filter. Once again, the same process happens, if the user is not authorized, then a challenge is sent back to browser, otherwise request pipeline moves.</p>
<p>Once the authentication and authorization are passed, request moves to the model binding step which collects data from query string, route data and request to generate objects required by Action method.</p>
<p>Once the model binding has been done, Action filters are triggered. Before action method is executed, an action filter is executed (OnActionExecuting) and after action method is executed, an action filter is executed (OnActionExecuted).</p>
<h3 id="action-invoker">Action Invoker</h3>
<p>It has the responsibilities of finding the action method in the controller and then invoking the action method.</p>
<p>To create a custom action invoker, you need to:</p>
<ul>
<li>Create a class that derives from IActionInvoker (or ControllerActionInvoker)</li>
</ul>
<pre><code class="language-C#">public class MyControllerActionInvoker: IActionInvoker
{
    public bool InvokeAction(ControllerContext controllerContext, string actionName)
    {
        var view = new StringBuilder();
        view.Append(&quot;&lt;div&gt;&quot;);
        view.Append(&quot;Content generated by my custom controller action invoker&quot;);
        view.Append(&quot;&lt;/div&gt;&quot;);
        controllerContext.HttpContext.Response.Write(view.ToString());
        return true;
    }
}
</code></pre>
<ul>
<li>Replace, in the controller factory, the action invoker for each concerned controller</li>
</ul>
<pre><code class="language-C#">mvcController.ActionInvoker = new MyControllerActionInvoker();
</code></pre>
<h3 id="model-binding">Model Binding</h3>
<p>It is the process that maps data from request to the method parameters.</p>
<p>When MVC receives an HTTP request, it routes it to a specific action method of a controller. It determines which action method to run based on what is in the route data, then it binds values from the HTTP request to that action method’s parameters.</p>
<p>MVC will try to bind request data to the action parameters by name. MVC will look for values for each parameter using the parameter name and the names of its public settable properties.</p>
<p>Model binding looks through default value providers, in the order, which are the components that feed data to model binders:</p>
<ul>
<li>Form values: These are form values that go in the HTTP request using the POST method. (including jQuery POST requests).</li>
<li>Route values: The set of route values provided by routing.</li>
<li>Query strings: The query string part of the URI.</li>
</ul>
<p>To create a custom value providers, you need to:</p>
<ul>
<li>Create a class that derives from IValueProvider</li>
</ul>
<pre><code class="language-C#">public class CustomValueProvider: IValueProvider
{
    public bool ContainsPrefix(string prefix)
    {
        return HttpContext.Current.Request.Cookies[prefix] != null;
    }

    public ValueProviderResult GetValue(string key)
    {
        return new ValueProviderResult(
            HttpContext.Current.Request.Cookies[key].Value,
            HttpContext.Current.Request.Cookies[key].Value.ToString(),
            CultureInfo.CurrentCulture);
    }
}
</code></pre>
<ul>
<li>Create a class that derives from ValueProviderFactory which will create the new value provider</li>
</ul>
<pre><code class="language-C#">public class CustomValueProviderFactory: ValueProviderFactory
{
    public override IValueProvider GetValueProvider(ControllerContext controllerContext)
    {
        return new CustomValueProvider();
    }
}
</code></pre>
<ul>
<li>Add the new value provider factory to the ValueProvidersFactories in Global.asax</li>
</ul>
<pre><code class="language-C#">ValueProviderFactories.Factories.Add(new CustomValueProviderFactory());
</code></pre>
<h3 id="filters">Filters</h3>
<h2 id="result-execution">Result Execution</h2>
<h1 id="http-module">Http Module</h1>
<p>It is an assembly that is called on every request that is made to your application.</p>
<p>You can override the default behavior or add custom logic by letting you attach event handlers to HttpApplication events.</p>
<p>To create a custom http handler, we need to</p>
<ul>
<li>Create a class that derives from IHttpModule</li>
</ul>
<pre><code class="language-C#">public class MyHttpModule: IHttpModule
{
    private bool disposed;
    private HttpApplication context;

    public void Init(HttpApplication context)
    {
        this.context = context;

        // With the context with have access to all http application events
        context.BeginRequest += OnBeginRequest;
    }

    private void OnBeginRequest(object sender, EventArgs e)
    {
        // CODE HERE
    }

    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }

    private void Dispose(bool disposing)
    {
        if (disposing)
        {
            if (!disposed)
            {
                context.BeginRequest -= OnBeginRequest;
                disposed = false;
            }
        }
    }
} 
</code></pre>
<ul>
<li>Create a class that register the new http module</li>
</ul>
<pre><code class="language-C#">public static class MyHttpModuleRegistration
{
    public static void Initialize()
    {
        DynamicModuleUtility.RegisterModule(typeof(MyHttpModule));
    }
}
</code></pre>
<ul>
<li>Run the registration before application start by adding the following line in the AssemblyInfo.cs</li>
</ul>
<pre><code class="language-C#">[assembly: PreApplicationStartMethod(typeof(MyHttpModuleRegistration), &quot;Initialize&quot;)]
</code></pre>
